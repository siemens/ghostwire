# nerdctl

[nerdctl](https://github.com/containerd/nerdctl) is a Docker-compatible CLI for
[containerd](https://containerd.io/). It is in itself **not a daemon**. And in
consequence, nerdctl does noth expose any API (and especially not any API
socket).

## Container Labels

nerdctl manages a set of _container_ labels in its own `nerdctl/` label
namespace that it requires in order to correctly operate. See also:
[nerdctl/labels/labels.go](https://github.com/containerd/nerdctl/blob/master/pkg/labels/labels.go)

> [!NOTE] nerdctl creates containers in containerd's `default` namespace and not
> in the Docker-reserved `moby` namespace.

- 🏷️ `nerdctl/name`: _optional_ container name – `nerdctl` does **not**
  automatically assign any auto-generated container names as Docker does. Thus,
  this label is only present if `--name foo_bar` has been specified on the CLI
  when creating a new container.
- 🏷️ `nerdctl/namespace`: the containerd namespace this container is in. (This
  probably is only of use in those situations where the correct container
  namespace context is lost, so it can be regenerated using this label.)
- 🏷️ `nerdctl/hostname`: the hostname to use inside the container. ...not that
  Gostwire can figure that out itself in a much more concise way be querying the
  actual UTS hostname.
  > [!WARNING] As of the time of this writing in September 2021
  > nerdctl/containerd do no create `/etc/hostname` inside containers. Only the
  > UTS hostname gets set. See also [issue
  > 376](https://github.com/containerd/nerdctl/issues/376).
- 🏷️ `nerdctl/extraHosts`: ... (can be _null_)
- 🏷️ `nerdctl/networks`: a JSON-encoded list of network names. These network
  names can be directly mapped to their corresponding CNI configuration files,
  by using the network name in place of the wildcard askterisk
  `/rtc/cni/net.d/nerdctl-*.conflist`.
- 🏷️ `nerdctl/state-dir`: contains dynamic container-related files, especially
  OCI hook-related log file(s) as well as the container's `resolv.conf`.

## Network Labels

nerdctl also supports attaching labels to nerdctl-managed networks, as Docker
does. These labels are stored in the CNI network configurations as field
name-value pairs in a JSON document 📃 `$.nerdctlLabels` object.

## CNI Networking

In contrast to Docker, nerdctl doesn't come with its own (integrated) network
drivers, but instead leverages existing CNI plugins. CNI has been made famous by
Kubernetes.

The CNI network configuration information is stored in
`/etc/cni/net.d/nerdctl-*.conflist` files – except for the default network with
ID 0 that doesn't get stored anywhere in the file system.

The command `nerdctl network inspect <ID>` basically just dumps the
JSON-formatted `.conflist` file corresponding with the specified ID, wrapped in
an outer `CNI` object.

> [!ATTENTION] For network ID 0 this information is auto-generated by `nerdctl`
> and not stored in the file system at all. The corresponding Gostwire decorator
> thus needs the corresponding a-priori knowledge about network ID 0 and cannot
> read it from the file system.

The following list of JSON element identifiers uses [JSON Path
notation](https://github.com/json-path/JsonPath):

- 📃 `$.name` (_string_): the name of the nerdctl-managed network.
- 📃 `$.nerdctlID` (_number_): ID of the nerdctl-managed network, ranging from
  1, 2, ... 
  > [!NOTE] ID 0 is the _default_ network and as the default network is
  > implicitly created, it does not appear in any `nerdctl-*.conflist` JSON
  > documents.
- 📃 `$.nerdctlLabels` (optional, _object_): optional object (dictionary) of
  name-value pairs.
- 📃 `$.plugins[*]` (_array of objects_): the plugins and configuration data
  required for creating this network.
  - 📃 `$.plugins[*].type` (_string_): for instance, type `bridge`.
  - 📃 `$.plugins[*].bridge` (optional, _string_): name of Linux bridge network
    interface (=bridge device).

## Bridge Networks

The mapping between `nerdctl` _network name_ ⇔ _network ID_ ⇔ Linux bridge
network _interface name_ can be deduced from...

- `$.name`: nerdctl-managed _network name_.
- `$.nerdctlID`: nerdctl-managed _network ID_.
- `$.plugins[*].bridge`: nerdctl-managed Linux bridge network _interface name_.

The particular Linux-kernel bridges are named `nerdctl0`, `nerdctl1`, ..., where
`0` is the network ID (from `CNI.nerdctlID`). Please do not confuse the
kernel-level bridge names with the user-level network names, these are two
completely separate sets of names.

## Installation

Unfortunately, Linux distributions seem to tend covering especially CNI rather
poorly as a standalone package. And nerdctl is still too young to be on the
radar (and maybe really never on the radar). Our `Makefile` comes to the rescue
and downloads and installs `nerdctl` and CNI plugins.

```bash
make install-tools
```

- `nerdctl` is installed into `/usr/local/bin`
- CNI plugins are installed into `/opt/cni/bin`
